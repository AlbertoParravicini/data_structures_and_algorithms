p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p
library(igraph)
library(dplyr)
library(ggplot2)
library(microbenchmark)
library(scales)
set.seed(32)
setwd("C:/Users/albyr/Documents/data_structures_and_algorithms/Project/")
results_points <- read.csv("Results/increasing_n_2016_11_24_12_26_38.csv", header = T, sep = ",")
results_hulls <- read.csv("Results/increasing_hull_2016_11_24_14_56_23.csv", header = T, sep = ",") %>% filter(time.sec. <= 15)
grouped_data_points <- results_points %>% group_by(input_size) %>% summarise_each(funs(median(.)), -iteration_number)
# INCREASING POINTS
p <- ggplot(grouped_data_points, aes(x= input_size, y = time.sec.))
# Linear regression of the points
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ input_size, data = grouped_data_points)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_points, aes(group = input_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = input_size, y = (input_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Number of pPoints") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with increasing number of points"), atop(italic(.("Hull size: 1000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
# INCREASING HULL SIZE
grouped_data_hulls <- results_hulls %>% group_by(hull_size) %>% summarise_each(funs(median(.)), -iteration_number)
p <- ggplot(grouped_data_hulls, aes(x= hull_size, y = time.sec.))
# Linear regression of the hull size
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ hull_size, data = grouped_data_hulls)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_hulls, aes(group = hull_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = hull_size, y = (hull_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Size of the Hull") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with hulls of increasing size"), atop(italic(.("Total number of points: 40000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
mape <- function(f, a) {
mean(abs(1 - f/a))
}
# SUPPORT PLOTS
# Draw a convex hull
X <- floor(matrix(runif(40)*20, ncol = 2))
X[chull(X),]
plot(X[chull(X),], type="l")
X_frame <- data.frame(X)[-c(3, 8),]
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
hull <- data.frame(X[chull(X),])
p <- p + geom_point(size = 3, color ="#a52918", data = hull, aes(x = X1, y = X2))
p <- p + geom_polygon(color ="#a52918", data = hull, aes(x = X1, y = X2), fill = "#ff9b8e", alpha = 0.2)
p <- p + theme_void()
p
# JARVIS MARCH
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p <- p + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = data.frame(x1 = 14.5, x2 = 15, y1 = 2, y2 = 5))
p
library(igraph)
library(dplyr)
library(ggplot2)
library(microbenchmark)
library(scales)
set.seed(32)
setwd("C:/Users/albyr/Documents/data_structures_and_algorithms/Project/")
results_points <- read.csv("Results/increasing_n_2016_11_24_12_26_38.csv", header = T, sep = ",")
results_hulls <- read.csv("Results/increasing_hull_2016_11_24_14_56_23.csv", header = T, sep = ",") %>% filter(time.sec. <= 15)
grouped_data_points <- results_points %>% group_by(input_size) %>% summarise_each(funs(median(.)), -iteration_number)
# INCREASING POINTS
p <- ggplot(grouped_data_points, aes(x= input_size, y = time.sec.))
# Linear regression of the points
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ input_size, data = grouped_data_points)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_points, aes(group = input_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = input_size, y = (input_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Number of pPoints") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with increasing number of points"), atop(italic(.("Hull size: 1000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
# INCREASING HULL SIZE
grouped_data_hulls <- results_hulls %>% group_by(hull_size) %>% summarise_each(funs(median(.)), -iteration_number)
p <- ggplot(grouped_data_hulls, aes(x= hull_size, y = time.sec.))
# Linear regression of the hull size
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ hull_size, data = grouped_data_hulls)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_hulls, aes(group = hull_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = hull_size, y = (hull_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Size of the Hull") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with hulls of increasing size"), atop(italic(.("Total number of points: 40000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
mape <- function(f, a) {
mean(abs(1 - f/a))
}
# SUPPORT PLOTS
# Draw a convex hull
X <- floor(matrix(runif(40)*20, ncol = 2))
X[chull(X),]
plot(X[chull(X),], type="l")
X_frame <- data.frame(X)[-c(3, 8),]
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
hull <- data.frame(X[chull(X),])
p <- p + geom_point(size = 3, color ="#a52918", data = hull, aes(x = X1, y = X2))
p <- p + geom_polygon(color ="#a52918", data = hull, aes(x = X1, y = X2), fill = "#ff9b8e", alpha = 0.2)
p <- p + theme_void()
p
# JARVIS MARCH
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p <- p + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = data.frame(x1 = 13, x2 = 15, y1 = 2, y2 = 5))
p
library(igraph)
library(dplyr)
library(ggplot2)
library(microbenchmark)
library(scales)
set.seed(32)
setwd("C:/Users/albyr/Documents/data_structures_and_algorithms/Project/")
results_points <- read.csv("Results/increasing_n_2016_11_24_12_26_38.csv", header = T, sep = ",")
results_hulls <- read.csv("Results/increasing_hull_2016_11_24_14_56_23.csv", header = T, sep = ",") %>% filter(time.sec. <= 15)
grouped_data_points <- results_points %>% group_by(input_size) %>% summarise_each(funs(median(.)), -iteration_number)
# INCREASING POINTS
p <- ggplot(grouped_data_points, aes(x= input_size, y = time.sec.))
# Linear regression of the points
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ input_size, data = grouped_data_points)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_points, aes(group = input_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = input_size, y = (input_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Number of pPoints") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with increasing number of points"), atop(italic(.("Hull size: 1000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
# INCREASING HULL SIZE
grouped_data_hulls <- results_hulls %>% group_by(hull_size) %>% summarise_each(funs(median(.)), -iteration_number)
p <- ggplot(grouped_data_hulls, aes(x= hull_size, y = time.sec.))
# Linear regression of the hull size
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ hull_size, data = grouped_data_hulls)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_hulls, aes(group = hull_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = hull_size, y = (hull_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Size of the Hull") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with hulls of increasing size"), atop(italic(.("Total number of points: 40000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
mape <- function(f, a) {
mean(abs(1 - f/a))
}
# SUPPORT PLOTS
# Draw a convex hull
X <- floor(matrix(runif(40)*20, ncol = 2))
X[chull(X),]
plot(X[chull(X),], type="l")
X_frame <- data.frame(X)[-c(3, 8),]
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
hull <- data.frame(X[chull(X),])
p <- p + geom_point(size = 3, color ="#a52918", data = hull, aes(x = X1, y = X2))
p <- p + geom_polygon(color ="#a52918", data = hull, aes(x = X1, y = X2), fill = "#ff9b8e", alpha = 0.2)
p <- p + theme_void()
p
# JARVIS MARCH
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p <- p + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = data.frame(x1 = 13, x2 = 15, y1 = 2, y2 = 5), curvature = 1)
p
library(igraph)
library(dplyr)
library(ggplot2)
library(microbenchmark)
library(scales)
set.seed(32)
setwd("C:/Users/albyr/Documents/data_structures_and_algorithms/Project/")
results_points <- read.csv("Results/increasing_n_2016_11_24_12_26_38.csv", header = T, sep = ",")
results_hulls <- read.csv("Results/increasing_hull_2016_11_24_14_56_23.csv", header = T, sep = ",") %>% filter(time.sec. <= 15)
grouped_data_points <- results_points %>% group_by(input_size) %>% summarise_each(funs(median(.)), -iteration_number)
# INCREASING POINTS
p <- ggplot(grouped_data_points, aes(x= input_size, y = time.sec.))
# Linear regression of the points
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ input_size, data = grouped_data_points)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_points, aes(group = input_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = input_size, y = (input_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Number of pPoints") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with increasing number of points"), atop(italic(.("Hull size: 1000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
# INCREASING HULL SIZE
grouped_data_hulls <- results_hulls %>% group_by(hull_size) %>% summarise_each(funs(median(.)), -iteration_number)
p <- ggplot(grouped_data_hulls, aes(x= hull_size, y = time.sec.))
# Linear regression of the hull size
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ hull_size, data = grouped_data_hulls)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_hulls, aes(group = hull_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = hull_size, y = (hull_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Size of the Hull") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with hulls of increasing size"), atop(italic(.("Total number of points: 40000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
mape <- function(f, a) {
mean(abs(1 - f/a))
}
# SUPPORT PLOTS
# Draw a convex hull
X <- floor(matrix(runif(40)*20, ncol = 2))
X[chull(X),]
plot(X[chull(X),], type="l")
X_frame <- data.frame(X)[-c(3, 8),]
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
hull <- data.frame(X[chull(X),])
p <- p + geom_point(size = 3, color ="#a52918", data = hull, aes(x = X1, y = X2))
p <- p + geom_polygon(color ="#a52918", data = hull, aes(x = X1, y = X2), fill = "#ff9b8e", alpha = 0.2)
p <- p + theme_void()
p
# JARVIS MARCH
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p <- p + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = data.frame(x1 = 13, x2 = 15, y1 = 2, y2 = 5), curvature = 1, angle = 90)
p
library(igraph)
library(dplyr)
library(ggplot2)
library(microbenchmark)
library(scales)
set.seed(32)
setwd("C:/Users/albyr/Documents/data_structures_and_algorithms/Project/")
results_points <- read.csv("Results/increasing_n_2016_11_24_12_26_38.csv", header = T, sep = ",")
results_hulls <- read.csv("Results/increasing_hull_2016_11_24_14_56_23.csv", header = T, sep = ",") %>% filter(time.sec. <= 15)
grouped_data_points <- results_points %>% group_by(input_size) %>% summarise_each(funs(median(.)), -iteration_number)
# INCREASING POINTS
p <- ggplot(grouped_data_points, aes(x= input_size, y = time.sec.))
# Linear regression of the points
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ input_size, data = grouped_data_points)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_points, aes(group = input_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = input_size, y = (input_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Number of pPoints") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with increasing number of points"), atop(italic(.("Hull size: 1000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
# INCREASING HULL SIZE
grouped_data_hulls <- results_hulls %>% group_by(hull_size) %>% summarise_each(funs(median(.)), -iteration_number)
p <- ggplot(grouped_data_hulls, aes(x= hull_size, y = time.sec.))
# Linear regression of the hull size
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ hull_size, data = grouped_data_hulls)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_hulls, aes(group = hull_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = hull_size, y = (hull_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Size of the Hull") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with hulls of increasing size"), atop(italic(.("Total number of points: 40000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
mape <- function(f, a) {
mean(abs(1 - f/a))
}
# SUPPORT PLOTS
# Draw a convex hull
X <- floor(matrix(runif(40)*20, ncol = 2))
X[chull(X),]
plot(X[chull(X),], type="l")
X_frame <- data.frame(X)[-c(3, 8),]
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
hull <- data.frame(X[chull(X),])
p <- p + geom_point(size = 3, color ="#a52918", data = hull, aes(x = X1, y = X2))
p <- p + geom_polygon(color ="#a52918", data = hull, aes(x = X1, y = X2), fill = "#ff9b8e", alpha = 0.2)
p <- p + theme_void()
p
# JARVIS MARCH
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p <- p + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = data.frame(x1 = 13, x2 = 15, y1 = 2, y2 = 5), curvature = 1, angle = 180)
p
library(igraph)
library(dplyr)
library(ggplot2)
library(microbenchmark)
library(scales)
set.seed(32)
setwd("C:/Users/albyr/Documents/data_structures_and_algorithms/Project/")
results_points <- read.csv("Results/increasing_n_2016_11_24_12_26_38.csv", header = T, sep = ",")
results_hulls <- read.csv("Results/increasing_hull_2016_11_24_14_56_23.csv", header = T, sep = ",") %>% filter(time.sec. <= 15)
grouped_data_points <- results_points %>% group_by(input_size) %>% summarise_each(funs(median(.)), -iteration_number)
# INCREASING POINTS
p <- ggplot(grouped_data_points, aes(x= input_size, y = time.sec.))
# Linear regression of the points
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ input_size, data = grouped_data_points)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_points, aes(group = input_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = input_size, y = (input_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Number of pPoints") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with increasing number of points"), atop(italic(.("Hull size: 1000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
# INCREASING HULL SIZE
grouped_data_hulls <- results_hulls %>% group_by(hull_size) %>% summarise_each(funs(median(.)), -iteration_number)
p <- ggplot(grouped_data_hulls, aes(x= hull_size, y = time.sec.))
# Linear regression of the hull size
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ hull_size, data = grouped_data_hulls)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_hulls, aes(group = hull_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = hull_size, y = (hull_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Size of the Hull") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with hulls of increasing size"), atop(italic(.("Total number of points: 40000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
mape <- function(f, a) {
mean(abs(1 - f/a))
}
# SUPPORT PLOTS
# Draw a convex hull
X <- floor(matrix(runif(40)*20, ncol = 2))
X[chull(X),]
plot(X[chull(X),], type="l")
X_frame <- data.frame(X)[-c(3, 8),]
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
hull <- data.frame(X[chull(X),])
p <- p + geom_point(size = 3, color ="#a52918", data = hull, aes(x = X1, y = X2))
p <- p + geom_polygon(color ="#a52918", data = hull, aes(x = X1, y = X2), fill = "#ff9b8e", alpha = 0.2)
p <- p + theme_void()
p
# JARVIS MARCH
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p <- p + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = data.frame(x1 = 11, x2 = 15, y1 = 2, y2 = 5), curvature = 1, angle = 180)
p
library(igraph)
library(dplyr)
library(ggplot2)
library(microbenchmark)
library(scales)
set.seed(32)
setwd("C:/Users/albyr/Documents/data_structures_and_algorithms/Project/")
results_points <- read.csv("Results/increasing_n_2016_11_24_12_26_38.csv", header = T, sep = ",")
results_hulls <- read.csv("Results/increasing_hull_2016_11_24_14_56_23.csv", header = T, sep = ",") %>% filter(time.sec. <= 15)
grouped_data_points <- results_points %>% group_by(input_size) %>% summarise_each(funs(median(.)), -iteration_number)
# INCREASING POINTS
p <- ggplot(grouped_data_points, aes(x= input_size, y = time.sec.))
# Linear regression of the points
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ input_size, data = grouped_data_points)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_points, aes(group = input_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = input_size, y = (input_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Number of pPoints") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with increasing number of points"), atop(italic(.("Hull size: 1000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
# INCREASING HULL SIZE
grouped_data_hulls <- results_hulls %>% group_by(hull_size) %>% summarise_each(funs(median(.)), -iteration_number)
p <- ggplot(grouped_data_hulls, aes(x= hull_size, y = time.sec.))
# Linear regression of the hull size
cols <- c("Real Data" = "#4f72fc", "Linear Model" = "#ff4d4d")
fit <- lm(time.sec. ~ hull_size, data = grouped_data_hulls)
p <- p + stat_boxplot(geom ='errorbar', width = 0, data = results_hulls, aes(group = hull_size, y = time.sec., col = "Real Data"), coef = 1)
p <- p + geom_line(size = 1, aes(x = hull_size, y = (hull_size * fit$coefficients[2] + fit$coefficients[1]), col = "Linear Model"), lineend = "round", linetype = "twodash")
p <- p + geom_line(size = 1.4, alpha = 0.6, aes(col = "Real Data"), linetype = "solid") + geom_point(size = 2, color ="#021f91")
p <- p + theme_minimal() + xlab("Size of the Hull") + ylab("Execution time [sec]")
p <- p + theme(axis.text=element_text(size=12), axis.title=element_text(size=14)) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_y_continuous(labels = comma)
p <- p + ggtitle(bquote(atop(.("Chan's algorithm with hulls of increasing size"), atop(italic(.("Total number of points: 40000")), ""))))
p <- p + scale_colour_manual(name="",values=cols) + theme(legend.position="top")
p
mape <- function(f, a) {
mean(abs(1 - f/a))
}
# SUPPORT PLOTS
# Draw a convex hull
X <- floor(matrix(runif(40)*20, ncol = 2))
X[chull(X),]
plot(X[chull(X),], type="l")
X_frame <- data.frame(X)[-c(3, 8),]
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
hull <- data.frame(X[chull(X),])
p <- p + geom_point(size = 3, color ="#a52918", data = hull, aes(x = X1, y = X2))
p <- p + geom_polygon(color ="#a52918", data = hull, aes(x = X1, y = X2), fill = "#ff9b8e", alpha = 0.2)
p <- p + theme_void()
p
# JARVIS MARCH
p <- ggplot(data = X_frame, aes(x = X1, y = X2)) + geom_point(size = 2, color ="#021f91")
p <- p
x_points_red = X_frame[c(3, 16, 4), ]
p <- p + geom_line(data = x_points_red, color = "#427af4")
p <- p + geom_point(size = 3, color ="#a52918", data = x_points_red, aes(x = X1, y = X2))
# Line tracing
x_targets = X_frame[c(7, 10, 12), ]
print(x_targets)
for (i in rownames(x_targets)) {
print(x_points_red[0, ])
print(data.frame(x_points_red["4", ], x_targets[i, ]))
p <- p + geom_line(data = rbind(x_points_red["4", ], x_targets[i, ]), color = "#f49e42")
}
p <- p + geom_line(data = rbind(x_points_red["4", ], X_frame["6", ]), color = "#a52918", size = 1)
p <- p + theme_void()
p
